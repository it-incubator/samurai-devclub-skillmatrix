# Fake Multithreading и "Concurrency" в JavaScript

## Fake Multithreading

JavaScript — это **однопоточный** язык, что означает, что он выполняет код поочередно в одном потоке. Однако, благодаря асинхронному выполнению задач и механизму **Event Loop**, он может создавать иллюзию многозадачности или многопоточности, называемую **Fake Multithreading** (фальшивый многозадачность).

### Как это работает:

1. **Event Loop** позволяет выполнять асинхронные задачи (например, таймеры, сетевые запросы) в фоновом режиме, при этом основной поток не блокируется.
2. Это дает ощущение, что код выполняется одновременно (многозадачность), хотя на самом деле он все еще работает в одном потоке.

### Пример Fake Multithreading:

```js
console.log('Start');

setTimeout(() => {
  console.log('Task 1');
}, 0);

setTimeout(() => {
  console.log('Task 2');
}, 0);

console.log('End');

// Start
// End
// Task 1
// Task 2
```

#### Почему "Task 1" и "Task 2" выполняются после "End"?

* Все синхронные задачи (`console.log('Start')` и `console.log('End')`) выполняются первыми.
* Асинхронные задачи (через `setTimeout`) попадают в очередь **макрозадач** и выполняются только после того, как стек вызовов (Call Stack) пуст.

## Concurrency

**Concurrency** (конкурентность) — это способность выполнять несколько задач в **параллель** или **взаимно** при одном потоке, разделяя время выполнения между задачами. В отличие от **параллельности** (где задачи выполняются одновременно на разных ядрах процессора), конкуренция в JavaScript описывает способность выполнять несколько задач асинхронно в одном потоке, разделяя его время.

### Важное различие:

* **Concurrency** — это способность системы управлять множеством задач в одно время, но не обязательно выполнять их параллельно.
* **Parallelism** (параллельность) — это выполнение нескольких задач одновременно, на разных ядрах или процессорах.

### "Concurrency":

```js
console.log('Start');

setTimeout(() => {
  console.log('Task 1');
}, 2000);

setTimeout(() => {
  console.log('Task 2');
}, 1000);

console.log('End');

// Start
// End
// Task 2    // выполнится первым (по времени)
// Task 1    // выполнится вторым (через 2 секунды)
```

#### Пояснение:

* Несмотря на то, что задачи выполняются последовательно в одном потоке, они не блокируют выполнение других операций.
* Это пример **конкурентности**, потому что две задачи (таймеры) выполняются с разными задержками, но все равно в одном потоке.

## Почему это называется "Fake Multithreading"?

JavaScript использует **однопоточный** механизм, но благодаря **Event Loop** и асинхронным операциям (таким как `setTimeout`, `Promises`, `fetch`), создается ощущение, что выполняются несколько задач одновременно. Однако на самом деле они выполняются по очереди в одном потоке.

## Как это связано с асинхронностью?

Асинхронный код позволяет избежать блокировки основного потока, что даёт возможность:

* Параллельно выполнять ввод/вывод (например, сетевые запросы, таймеры).
* Ожидать завершения долгих операций (например, чтение файла, сетевые запросы) без блокировки основного потока исполнения.